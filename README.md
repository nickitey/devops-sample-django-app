<h1>Party Parrot App</h1>

<img src='media/images/party-parrot.gif' alt='parrot' height="200" width="200">
<br>
<br>
<h3></h3>

Sample Python application on Django with PostgreSQL database.


## Deployment with Docker/Развертывание проекта с Docker

**TL;DR**: для запуска проекта необходимо предоставить сервису `.env`-файл с переменными окружения, необходимыми для конфигурирования сервиса при запуске, расположив его в корневой директории проекта, аналогичный по структуре файлу `.env.example` (для тестового запуска можно просто переименовать `.env.example` в `.env`).

После этого в консоли/терминале, находясь в этой же корневой директории проекта, необходимо написать команду:

```bash
    docker compose up --build
```

Все работает.

<br><br>

**Подробнеее**.

Проект составлен из двух Docker-контейнеров:
- контейнер с СУБД PostgreSQL на основе готового образа с [hub.docker.com](https://hub.docker.com/_/postgres). Необходимые переменные окружения (имя пользователя PostgreSQL, пароль и название БД) в контейнер передаются путем интерполяции переменных окружения из `.env`-файла[^1];
- контейнер с веб-приложением на Django на основе образа, создаваемого из Dockerfile. Переменные окружения, необходимые для подключения приложения к БД, передаются целиком файлом. 

Сохранность данных в БД при перезапуске контейнера обеспечивается путем создания тома (volume) на хост-машине. Создавать том для python-приложения скорее нецелесообразно, оно не хранит данные, которые было бы трудно восстановить[^2].

При сборке образа `pip` может выдавать предупреждение, что "_установка из-под рута скорее плохо, чем хорошо_", но тут палка о двух концах.

С одной стороны, действительно устанавливать глобально зависимости для Python не принято, и для установки на уровне пользователя есть соответствущий флаг:

```bash
    pip install --user <package_name>
```

С другой стороны, есть широко известная[^3] проблема, когда попытка установки зависимости на уровне пользователя **внутри виртуального окружения** [ломает некоторые пути окружения](https://stackoverflow.com/a/56948334).

Поскольку Docker-контейнер, по сути, как раз и является вот таким **изолированным виртуальным окружением**, здесь скорее проще пренебречь предупреждением пакетного менеджера.

Зависимости устанавливаются сначала из прилагаемого файла `requirements.txt`, а затем дополнительно устанавливается uWSGI. В ТЗ указано, что приложение должно подниматься на uWSGI-сервере, но не указано, что нужно как-то менять уже имеющийся в репозитории список зависимостей. Поэтому он устанавливается каждый раз при запуске контейнера.

При сборке контейнера на уровне ОС устанавливается gcc-компилятор, поскольку без него не собирается uWSGI.

Файл `uwsgi.ini` содержит необходимые настройки для запуска uWSGI, в частности, в нем указано, что запускается 3 экземпляра веб-приложения (workers), а также указан порт, который сервер слушает. Некоторые настройки можно было бы также вынести в переменные окружения (тем более uWSGI [умеет с ними работать](https://uwsgi.readthedocs.io/en/latest/Configuration.html#command-line-arguments)), но для тестового задания вполне достаточно, что оно просто работает и относительно легко конфигурируется.

С запуском контейнера PostgreSQL есть некоторая особенность. Первый запуск контейнера (точнее, запуск контейнера в отсутствие volume) запускает процедуру инициализации сервиса, а затем перезапуск контейнера. В это же время веб-приложение пытается подключиться к БД для осуществления миграции, однако сервис БД еще не готов принимать подключения, из-за чего веб-приложение падает.

<img src="https://www.meme-arsenal.com/memes/4cceb80c8fc91e48a9dceac6e99260c3.jpg" height="400" width="400" />

В `docker-compose.yml` есть поле `depends_on`, которое определяет очередность запуска контейнеров, но его стандартное поведение - это дать сигнал к запуску зависимого контейнера, когда запущен контейнер, указанный в зависимостях. При этом `depends_on` не заботится о состоянии контейнера-зависимости, самого факта его успешного запуска уже достаточно, что в данной ситуации совершенно не спасает от критической ошибки в контейнере веб-приложения.

Поэтому для контейнера PostgreSQL в `docker-compose.yml` указан healthcheck при помощи стандартной утилиты PostgreSQL `pg_isready`. Если healthcheck прошел - сервис "здоров" и готов к подключению и миграции.

## Checklist готовности ТЗ


> Критерии приемки:
> - Приложение собирается и развертывается через docker-compose

Приложение собирается и развертывается через docker compose.

> - Приложение полностью работоспособно после запуска (можно открыть в браузере, работает функционал создания постов на главной странице)

Оно полностью работоспособно, в браузере по адресу [127.0.0.1:8000](127.0.0.1:8000)[^4] доступно веб-приложение, осуществляются переходы по ссылкам в правом верхнем углу, происходит добавление статей про попугаев, которые доступны на главной странице.

> - Приложение не теряет оставленные посты после перезапуска docker-compose

Приложение не теряет оставленные посты после перезапуска docker-compose, поскольку в docker при первом запуске будет создан том (*volume*), который сохранит на хост данные из БД внутри контейнера.


[^1]: В задании скорее содержался намек на то, что переменные окружения было бы неплохо передавать в самом docker-compose.yml (или мне так показалось), но, поскольку некоторые переменные используются в двух контейнерах сразу (собственно, через один источник переменных осуществляется синхронизация параметров для подключения приложения к БД), решено добавить их в отдельный файл.
[^2]: За исключением, пожалуй, некоторых старых версий пакетов, которые **пока еще** доступны. На Python 3.12 Pillow 9 версии уже не ставится.
[^3]: ... в узких кругах :).
[^4]: Аналогично по адресу [localhost:8000](localhost:8000).